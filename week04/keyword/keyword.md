# 계층형 구조 vs 도메인형 구조
### 계층형 구조

---

애플리케이션의 **역할(Layer) 또는 기능적 관심사**를 기준으로 코드를 분리하는 방식.

**분리 기준:** 애플리케이션의 기술적 역할 (예: 프레젠테이션, 비즈니스 로직, 데이터 접근).

**패키지 구조 예시:**

```json
└── com.example.umc9th
    ├── controller  (프레젠테이션/API 계층: 사용자 요청 처리)
    ├── service     (비즈니스 로직 계층: 핵심 로직 처리)
    └── repository  (데이터 접근 계층: 데이터베이스 통신)
```

**장점:**

- **명확한 역할 분리:** 각 계층의 역할이 명확하여 코드를 이해하기 쉽고 프로젝트의 전체적인 **흐름**을 빠르게 파악할 수 있음.
- **테스트 용이성:** 각 계층별로 독립적인 테스트가 비교적 용이.
- **익숙함:** 많은 개발자에게 익숙하고 전통적인 패턴.

**단점:**

- **도메인 응집도 낮음:** 하나의 도메인에 관련된 코드가 여러 계층(controller, service, repository)에 흩어져 있어 **도메인의 흐름**을 파악하기 어려움.
- **확장성 및 유지보수:** 프로젝트 규모가 커지면 하나의 패키지(예: `service`) 안에 너무 많은 클래스가 모여 관리하기 어려워지고, 한 도메인의 변경이 여러 계층의 파일에서 발생해야 하므로 변경 범위가 넓어질 수 있음.

### 도메인형 구조

---

**도메인 주도 설계(Domain-Driven Design, DDD)** 원칙에 기반하여 애플리케이션의 핵심 비즈니스 도메인을 중심으로 코드를 분리하는 방식.

**분리 기준:** 애플리케이션이 다루는 **핵심 비즈니스 개념** 또는 **유스케이스(Use-Case)** (예: 회원, 주문, 결제).

**패키지 구조 예시:**

```json
└── com.example.umc9th
    ├── member      
    │   ├── controller
    │   ├── service
    │   └── repository
    └── Food
    │   │   ├── controller
    │   ├── service
    │   └── repository
    └──
```

**장점:**

- **높은 도메인 응집도:** 특정 도메인과 관련된 모든 코드가 해당 도메인 패키지 내에 응집되어 있어 **도메인의 흐름과 로직**을 한눈에 파악하기 쉬움.
- **변경에 강함:** 한 도메인의 변경이 다른 도메인에 미치는 영향을 최소화하여 유지보수 및 확장성이 우수함.
- **모듈화 용이:** 각 도메인 자체가 독립적인 모듈 역할을 수행할 수 있어 마이크로 서비스 아키텍처 등에 적합.

**단점:**

- **전반적인 흐름 파악 어려움:** 애플리케이션의 **기술적인 전체 흐름**을 파악하기 위해서는 여러 도메인 패키지를 넘나들어야 할 수 있어 초기 학습 곡선이 높을 수 있음.
- **작은 프로젝트에 부적합:** 도메인 분리가 명확하지 않거나 규모가 작은 프로젝트에서는 불필요하게 복잡하게 느껴질 수 있음.
- **도메인 간 협력 복잡성:** 여러 도메인이 상호 작용해야 하는 경우, 구조 설계가 복잡해질 수 있음.

# JPA
개발자가 SQL을 직접 작성하지 않고도 자바 코드를 통해 데이터베이스와 상호 작용할 수 있도록 도와주는 기술.

## 1. JPA의 핵심 개념

### ORM (Object-Relational Mapping)

- **객체(Object)**: 자바 애플리케이션에서 사용하는 클래스 인스턴스 (예: `User`, `Product`).
- **관계형 데이터(Relational Data)**: 데이터베이스의 테이블과 행 (Row) 데이터.
- **매핑(Mapping)**: 이 둘을 서로 연결하여, 마치 자바 객체를 다루듯이 데이터베이스 데이터를 조작할 수 있게 합니다.

개발자는 SQL 대신 **메소드 호출**이나 **객체 상태 변경**을 통해 데이터를 저장, 조회, 수정, 삭제. JPA가 이 작업을 대신 SQL로 번역하여 데이터베이스에 전달.

### 표준 명세와 구현체

JPA는 그 자체로 **API(표준 명세)**일 뿐, 실제 동작하는 **프레임워크(구현체)**는 아닙니다.

| 구분 | 설명 | 예시 |
| --- | --- | --- |
| **JPA** | **표준 명세 (API)** | 데이터 지속성을 위해 지켜야 할 규칙과 인터페이스를 정의 |
| **구현체** | **실제 프레임워크** | JPA 명세를 구현한 실제 소프트웨어 |

---

## 2. JPA의 주요 특징

### 1. 생산성 향상

반복적인 SQL 작성 작업을 줄여주고 객체 지향적인 방식으로 개발할 수 있어 생산성↑.

### 2. 유지보수 용이

테이블 필드가 변경되어도 객체 필드만 수정하면 되므로 데이터베이스 종속성이 줄어들고 유지보수가 쉬워짐.

### 3. 데이터베이스 독립성

애플리케이션 코드를 크게 수정하지 않고도 데이터베이스(예: MySQL ↔ Oracle)를 교체할 수 있음 → JPA 구현체가 각 DB에 맞는 SQL을 대신 생성해 주기 때문에

### 4. 객체와 관계형 데이터의 패러다임 불일치 해결

객체 지향적인 설계와 관계형 데이터베이스의 테이블 구조 사이의 차이(패러다임 불일치)를 중간에서 해결함.

---

## 3. JPA를 사용하기 위한 핵심 요소
| 요소 | 설명 |
| --- | --- |
| **엔티티 (Entity)** | - 데이터베이스 테이블과 매핑되는 **자바 클래스
-** `@Entity` 어노테이션을 사용 |
| **영속성 컨텍스트 (Persistence Context)** | - 엔티티를 **영구히 저장하는 환경** 
- 엔티티를 관리하는 논리적인 영역으로, 데이터베이스와의 연결을 추상화 |
| **EntityManager** | - 영속성 컨텍스트에 접근하여 엔티티를 **등록, 수정, 삭제, 조회**하는 역할
- 개발자는 주로 이 객체를 통해 JPA를 사용 |
| **JPQL (Java Persistence Query Language)** | - 객체를 대상으로 하는 **쿼리 언어
-** SQL과 문법이 유사하지만, 테이블이 아닌 엔티티 객체를 대상으로 쿼리를 작성  |

# N+1 문제
### 의미

---

1개의 쿼리를 보낸 후(N), 연관된 엔티티들을 가져오기 위해 추가로 1개의 쿼리를 각 엔티티마다 보내는  문제. 데이터 조회 시 **한 번의 조회(N)** 이후, 관련된 데이터를 각각 **추가 조회(+1)** 하면서 발생하는 성능  문제. (ex. 리스트로 엔티티를 가져왔는데, 각 엔티티에 연관된 데이터를 또 DB에서 매번 조회하는 상황.)

### 발생 원인

---

관계형 데이터베이스와 객체지향 언어간의 패러다임 차이로 인해 발생.
객체는 연관관계를 통해 레퍼런스를 가지고 있으면 언제든지 메모리 내에서 **Random Access**를 통해 연관 객체에 접근할 수 있지만 RDB의 경우 **Select 쿼리**를 통해서만 조회할 수 있기 때문. JPA 기본 설정이 `LAZY` 로딩이기 때문.
= 그래서 부모(예: Member)만 먼저 가져오고, 그 다음에 각 Member에 연결된 Orders를 **하나하나** 추가 조회하는 것임.

### N+1이 문제가 되는 이유

---

N+1문제가 발생하면 쿼리가 배수적으로 증가하면서 DB에 큰 부담이 발생하게 되고 장애 요인이 될 수 있음. 또한 사용자 관점에서 지연율 또한 크게 증가할 수 있기 때문.

ex)

@OneToMany(mappedBy = "member", cascade = CascadeType.ALL)
private List<MemberAgree> memberAgreeList = new ArrayList<>();

MemberAgree를 조회하는 게 N, 이후 get이 +1.

# 기본키 생성 전략
JPA(Java Persistence API)에서 **기본 키(Primary Key) 생성 전략**은 엔티티의 식별자(ID) 값을 어떻게 할당할지 결정하는 중요한 설정.

**직접 할당**과 **자동 생성**이 있음.

자동 생성 전략은 `@GeneratedValue` 어노테이션의 `strategy` 속성을 사용하여 지정하며, 데이터베이스의 특성을 활용하는 다양한 방법이 있습니다.

---

## 1. 직접 할당 (Manual Assignment)

애플리케이션 개발자가 **직접** 기본 키 값을 생성하고 엔티티에 할당.

- **설정:** `@Id`만 사용하고 `@GeneratedValue`는 사용하지 X.
- **특징:**
    - 비즈니스 로직과 관련된 키(예: 주민등록번호, 이메일, UUID)를 사용하거나, 이미 존재하는 시스템의 키를 그대로 사용할 때 유용.
    - `em.persist()`를 호출하기 전에 개발자가 직접 키 값을 설정해야함.

```json
@Entity
public class Member {
    @Id
    private String memberId; // 개발자가 직접 할당
    // ...
}
```

---

## 2. 자동 생성 (Automatic Generation)

데이터베이스나 JPA 구현체에 키 생성을 **위임**하는 방식.
`@GeneratedValue(strategy = GenerationType.XXX)`를 사용하여 전략을 선택.

### 2.1. GenerationType.IDENTITY (데이터베이스 위임)

기본 키 생성을 데이터베이스의 **AUTO_INCREMENT** 기능에 완전히 위임.

- **사용 DBMS:** MySQL, PostgreSQL, SQL Server 등
- **장점:** 데이터베이스에 맡기므로 가장 단순하고 직관적.
- **단점 (중요):**
    - `em.persist()`를 호출하는 **즉시** `INSERT` SQL이 데이터베이스에 실행되어야 식별자(ID) 값을 알 수 있음.
    - 따라서, JPA의 핵심 최적화 기능 중 하나인 트랜잭션 쓰기 지연(쓰기 지연 SQL 저장소)이 동작 X.

```json
@Entity
public class Board {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    // ...
}
```

### 2.2. GenerationType.SEQUENCE (데이터베이스 시퀀스 활용)

데이터베이스의 시퀀스를 사용하여 기본 키 값을 할당 받음.

- **사용 DBMS:** Oracle, PostgreSQL, DB2 등 (시퀀스 오브젝트를 지원하는 DB)
- **장점:**
    - 키 값을 먼저 할당 받을 수 있어 `em.persist()` 시점에 ID를 알고 있으므로 **쓰기 지연**이 가능.
    - 데이터베이스 트랜잭션과 별개로 동작하여 안전하고 성능 최적화가 용이.
- **최적화:** `allocationSize` 설정을 통해 시퀀스 접근 횟수를 줄여 성능을 최적화할 수 있음. (예: DB에서 50개의 시퀀스 값을 미리 할당받아 메모리에서 사용 후, 모두 사용하면 다시 DB에 요청)

```json
@Entity
@SequenceGenerator(
    name = "MEMBER_SEQ_GENERATOR", // 시퀀스 생성기 이름
    sequenceName = "MEMBER_SEQ",   // DB 시퀀스 이름
    initialValue = 1,
    allocationSize = 50            // 성능 최적화 설정
)
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "MEMBER_SEQ_GENERATOR")
    private Long id;
    // ...
}
```

### 2.3. GenerationType.TABLE (키 생성 테이블 활용)

별도의 **키 생성 전용 테이블**을 만들고, 여기에 일련의 값을 저장하여 시퀀스를 흉내 내는 전략.

- **특징:** 모든 데이터베이스에서 사용할 수 있지만, 키 생성 시마다 테이블에 `SELECT`와 `UPDATE`를 사용해야 하므로 **성능이 가장 떨어짐.**

### 2.4. GenerationType.AUTO (자동 선택)

선택된 데이터베이스 방언(Dialect)에 따라 **IDENTITY, SEQUENCE, TABLE** 중 하나를 JPA 구현체(Hibernate 등)가 **자동으로 선택**.

- **권장:** 특정 DB에 종속되지 않는 범용적인 코드를 작성할 때 사용하나, 구체적인 전략을 명시하는 것이 더 명확하고 예측 가능하므로 **실무에서는 특정 전략을 명시**하는 것을 권장하는 경우가 많음.

---

## ✨ 핵심 권장 전략 (실무 관점)

| DBMS 종류 | 권장 전략 | 이유 |
| --- | --- | --- |
| **MySQL, SQL Server** | **`GenerationType.IDENTITY`** | 데이터베이스의 Auto Increment 기능을 활용하는 것이 일반적 |
| **Oracle, PostgreSQL** | **`GenerationType.SEQUENCE`** | 시퀀스 기능을 활용하여 JPA의 쓰기 지연을 활성화하고 성능 최적화가 가능 |