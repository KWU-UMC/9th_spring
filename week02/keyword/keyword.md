# WEEK 2 - 하지명

---
### 핵심 키워드
- SOLID
- DI
- IoC
- 생성자 주입 vs 수정자, 필드 주입 차이
- AOP
- 서블릿
---

### 1. SOLID
객체 지향 설계에서 지켜야 할 5개의 소프트웨어 개발 원칙
1. **SRP** (Single Responsibility Principle): 단일 책임 원칙  
    - 하나의 클래스는 하나의 기능을 담당하여 하나의 책임을 수행하는데 집중되도록 클래스를 따로 여러 개 설계하라는 원칙
    - 목적: 프로그램의 ***유지보수성***을 높이기 위한 설계 기법

2. **OCP** (Open Closed Principle): 개방 폐쇄 원칙
    - 클래스는 확장에 열려 있어야하며, 수정에는 닫혀있어야 함
    - 목적: _**추상화**_ 사용을 통한 관계 구축을 권장하는 것

3. **LSP** (Listov Substitution Principle): 리스코트 치환 원칙
    - 서브 타입은 언제나 부모 타입으로 교체할 수 있어야 함
    - _**다형성**_ 원리를 이용하기 위한 원칙

4. **ISP** (Interface Segregation Principle): 인터페이스 분리 원칙
    - 인터페이스를 각각 사용에 맞도록 잘게 분리해야함
    - 목적: 인터페이스를 사용하는 클라이언트를 기준으로 분리하여, 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공하는 것

5. **DIP** (Dependency Inversion Principle): 의존 역전 원칙
    - class를 참조하는 것이 아닌 대상의 상위 요소를 참조함
    - 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 원칙

SOLID 객체 지향 원칙을 적용하면 코드를 확장하고 유지 보수 관리하기가 더 쉬워지며,
불필요한 복잡성을 제거해 리팩토링에 소요되는 시간을 줄임으로써 프로젝트 개발의 생산성을 높일 수 있음


### 2. DI
IoC를 실현하는 방법 중 하나로 객체가 필요로 하는 것을 직접 만들지 않고, 외부에서 주입받는 방식  

#### **의존관계 주입 조건**
1. 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스만 의존하고 있어야 한다.
2. 런타임 시점의 의존관계는 컨테이너나 팩토리같은 제 3의 존재가 결정한다.
3. 의존관계는 사용할 객체에 대한 래퍼런스를 외부에서 제공해줌으로써 만들어진다.

#### **Spring의 의존성 주입 방식**
1. 생성자 주입(Constructor Injection)
2. setter 주입(Setter Injection)
3. 필드 주입(Field Injection)

### 3. IoC
제어의 역전  
프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것  

일반적으로 프로그램을 작성할 대는 객체의 생성, 설정, 초기화, 메서드 호출, 소멸까지의 모든 과정을 개발자가 제어함  
하지만, 프레임워크를 사용하면 객체의 생명 주기를 모두 프레임워크에 위임할 수 있음.
즉, 외부 라이브러리가 프로그래머가 작성한 코드를 호출하고, 흐름을 제어하는 것  

#### **Spring IoC 컨테이너**  
Spring IoC 컨테이너는 객체의 생성과 관리를 Spring 프레임워크가 담당하는 것  

#### IoC 컨테이너 작동 방식
1. 객체를 class로 정의
2. 객체들 간의 연관성을 지정: Spring 설정 파일 또는 어노테이션을 통해 객체들이 어떻게 연결될지 지정
3. IoC 컨테이너가 이 정보를 바탕으로 객체들을 생성하고 필요한 곳에 주입

### 4. 생성자 주입 vs 수정자, 필드 주입 차이
#### 생성자 주입
- 의존성을 생성자 매개변수로 받는 방식
- `final` 키워드 사용 가능
- 필수 의존성 주입에 적합
- 객체가 생성될 때 의존성이 주입되므로 NPE 방지에 유리
- 테스트와 DI 컨테이너 없이 순수 자바 코드로 객체를 만들 때 편리
#### 수정자 주입
- `setter` 메서드를 통해 의존성을 주입하는 방식
- 선택적 의존성이 있을 때 유용
- 객체 생성 이후에 의존성을 변경 가능
- 불변성이 깨질 수 있음 -> 상태가 바뀌면 예측하기 어려움
#### 필드 주입
- 필드에 직접 의존성을 주입하는 방식
- 코드가 간단해보임
- 테스트나 유지보수에 불리
  - DI 컨테이너 없이는 객체 생성이 어렵
  - `final` 키워드 사용 불가능
- 테스트 코드에서만 사용하는 것을 권장

### 5. AOP
- AOP(Aspect Oriented Programming 관점 지향 프로그래밍)  
- 공통 관심사를 핵심 비즈니스 로직과 분리해 관리하는 프로그래밍 패러다임
- 로깅, 트랜잭션 관리, 보안, 성능 모니터링 등 여러 모듈에서 공통적으로 필요한 기능을 한 곳에 모아두고, 자동으로 적용 가능

#### AOP의 핵심 개념
1. Aspect: 공통 기능을 모아둔 모듈 (ex. 로깅, 트랜잭션 등)
2. Joint Point: 공통 기능을 적용할 수 있는 모든 지점 (ex. 메서드 실행, 객체 생성 등)
3. Pointcut: Join Point 중 실제로 Aspect를 적용할 위치를 지정하는 표현식
4. Advice: 실제 실행될 공통 기능 코드 (ex. Before, After, Around 등)
5. Weaving: Aspect를 핵심 로직 코드에 적용하는 과정

#### AOP 장점
- 공통 관심사의 코드 중복 제거
- 핵심 로직과 공통 로직 분리 -> 가독성/유지보수성 향상
- 코드 변경 없이 공통 기능 추가/수정 가능

#### AOP 한계
- 기본적으로 프록시 기반이라 메서드 호출에만 적용 가능
- 생성자, 필드 접근 불가

### 6. 서블릿
자바로 작성된 서버 측 프로그램으로 클라이언트의 요청을 처리하고 응답을 생성하는 역할  
웹 서버가 HTTP 요청을 받으면 서블릿 컨테이너가 서블릿을 실행해 응답을 만들어 브라우저로 돌려보냄  
`HTTP 요청 -> 서블릿에서 처리 -> HTML/JSON 등으로 응답 반환`  

#### 서블릿 동작 흐름
1. 클라이언트가 URL 요청
2. 서블릿 컨테이너가 URL 매핑에 따라 해당 서블릿을 찾아 실행
3. 서블릿이 요청 처리 로직 수행
4. 결과를 HttpServletResponse 객체를 통해 응답으로 전송  

#### 서블릿의 핵심 클래스
- `HttpServlet`: GET, POST 같은 HTTP 메서들별 처리 지원
- `HttpServletRequest`: 클라이언트 요청 정보를 담고 있음(파라미터, 헤더, 바디 등)
- `HttpServletResponse`: 클라이언트로 돌려보낼 응답 정보를 담음(상태 코드, 헤더, 바디 등)

#### 서블릿 컨테이너  
서블릿 자체는 단순 자바 클래스인데 이를 웹 환경에서 동작하게 하려면 서블릿 컨테이너가 필요  
##### 기능
- 서블릿 객체 생성 및 초기화
- HTTP 요청/응답 객체 생성
- 서블릿 메서드 호출
- 멀티스레드 처리
