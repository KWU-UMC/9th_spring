# **SOLID**

  객체 지향 프로그래밍(OOP) 및 소프트웨어 설계에서 사용되는 5가지 핵심 원칙의 약자. **유연하고 유지보수가 쉬운 시스템**을 만드는 것이 목표. 스프링은 이 원칙들을 따르도록 설계되어 있음.

  ### 1. 단일 책임 원칙 (Single Responsibility Principle, SRP)

  한 클래스는 **하나의 책임**만 가져야 한다는 원칙.

  ex) 사용자 정보를 다루는 `User` 클래스가 있다면 이 클래스는 사용자의 데이터(이름, 이메일 등)를 관리하는 책임만 가져야 하고 사용자에게 이메일을 보내는 기능 같은 것은 별도의 `EmailService` 클래스에 분리하는 게 좋음.

  ### 2. 개방-폐쇄 원칙 (Open-Closed Principle, OCP)

  **확장에는 열려 있고, 변경에는 닫혀 있어야** 한다는 원칙.
  새로운 기능을 추가할 때 기존 코드를 수정하지 않고도 확장할 수 있도록 설계해야 함. 스프링에서는 인터페이스를 활용해 이 원칙을 잘 구현할 수 있음.

  ex) `PaymentService` 인터페이스를 만들고 `CreditCardPayment`와 `KakaoPayPayment` 클래스가 이 인터페이스를 구현하게 하면 새로운 결제 수단이 추가되어도 기존 `PaymentService` 코드를 수정할 필요 없이 새로운 클래스만 추가하면 됨.

  ### 3. 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)

  자식 클래스는 **언제든 부모 클래스를 대체할 수 있어야** 한다는 원칙.
  즉, 부모 클래스를 사용하는 곳에 자식 클래스를 넣어도 프로그램의 기능이 정상적으로 동작해야 함.

  ex) `Bird` 클래스와 이를 상속받는 `Penguin` 클래스가 있다고 할 때, `Bird` 클래스에 `fly()` 메서드가 있다면, `Penguin` 클래스도 이 메서드를 구현해야 하지만, 펭귄은 날 수 없으므로 이 원칙에 위배될 수 있음.

  ### 4. 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)

  클라이언트는 자신이 사용하지 않는 인터페이스에 의존해서는 안 된다는 원칙.
  즉, **인터페이스를 기능별로 작게 분리**해야 해함.

  ex) 하나의 거대한 `SmartDevice` 인터페이스보다는 `Controllable`, `Displayable` 등 용도에 맞는 작은 인터페이스로 나누는 게 더 효율적임.

  ### 5. 의존성 역전 원칙 (Dependency Inversion Principle, DIP)

  고차원 모듈은 저차원 모듈에 의존해서는 안 되며, 둘 다 **추상화된 것에 의존해야** 한다는 원칙.

  ex) 스프링의 **의존성 주입(Dependency Injection, DI)** 기능이 이 원칙을 구현하는 대표적인 예시. `Controller`가 `Repository`를 직접 생성하는 대신, 인터페이스(추상화)를 통해 의존성을 주입받아 사용함으로써 결합도를 낮출 수 있음.

# **DI**

  객체 지향 프로그래밍에서 한 객체가 다른 객체의 의존성을 직접 생성하거나 관리하지 않고 외부에서 주입 받음. **스프링 프레임워크의 핵심 기능** 중 하나로, 유연하고 테스트하기 쉬운 코드를 만드는 데 필수적임.

  ### DI의 기본 개념
    
  ---

  객체 A가 객체 B의 기능을 사용해야 할 때, 객체 B는 객체 A의 **의존성**. DI가 없으면 객체 A는 객체 B를 직접 생성하거나 찾아와서 사용해야 함.
  하지만 **DI를 사용**하면 객체 A는 자신이 필요한 객체 B를 누군가가 **넣어주기를 기다림.** 즉, 객체 A가 의존성을 능동적으로 찾는 대신, **수동적으로 주입 받음**.

  ### DI의 장점
    
  ---

    1. **높은 유연성**: 한 객체가 다른 객체를 직접 생성하지 않기 때문에, 의존하는 객체를 쉽게 바꿀 수 있음.
    2. **낮은 결합도**: 객체 간의 의존성이 느슨해져서 한 객체를 수정해도 다른 객체에 미치는 영향이 적음.
    3. **코드 재사용성 증가**: 의존하는 객체를 쉽게 교체할 수 있으므로, 여러 곳에서 동일한 코드를 재사용하기 용이함.

  ### DI의 종류
    
  ---

  ### 1. 생성자 주입 (Constructor Injection)

  생성자의 매개변수로 의존성을 주입받는 가장 권장되는 방법.
  의존성을 변경할 수 없고, 순환 의존성을 방지하는 등의 장점이 있어 가장 많이 사용되는 방법.

  **예시**:

    ```java
    public class UserService {
        private final UserRepository userRepository;
    
        public UserService(UserRepository userRepository) {
            this.userRepository = userRepository;
        }
    }
    ```

  ### 2. 수정자 주입 (Setter Injection)

  수정자(Setter) 메서드를 통해 의존성을 주입하는 방법. 선택적인 의존성을 주입할 때 유용하지만, 주입받는 객체가 변경될 수 있다는 단점이 있음.

  **예시**:

    ```java
    public class UserService {
        private UserRepository userRepository;
    
        public void setUserRepository(UserRepository userRepository) {
            this.userRepository = userRepository;
        }
    }
    ```

  ### 3. 필드 주입 (Field Injection)

  `@Autowired` 같은 어노테이션을 필드에 직접 붙여 의존성을 주입하는 방법. 코드가 간결해 보이지만, 외부에서 변경하기 어렵고 테스트하기 불편하다는 단점이 있어 권장하는 방법은 아님.

  **예시**:

    ```java
    @Component
    public class UserService {
        @Autowired
        private UserRepository userRepository;
    }
    ```

# **IoC**

  **스프링 프레임워크**의 핵심 개념 중 하나로, **객체의 생성, 생명 주기 관리 및 의존성 주입**을 개발자가 아닌 **컨테이너**가 대신 처리하는 것을 의미.
  객체 자신이 필요로 하는 **다른 객체를 직접 생성하고 관리하지 않고 스프링 컨테이너에 넘겨줌**. 컨테이너가 필요한 객체들을 미리 생성하고 객체가 필요로 하는 의존성을 외부에서 주입해줌.

  ### **IoC와 DI (Dependency Injection)의 관계**

  IoC는 '제어의 역전'이라는 추상적인 개념을 나타내며, **DI**는 이 IoC를 구현하는 구체적인 **디자인 패턴**. 즉, 의존성을 주입하는 방식(DI)을 통해 제어의 주체를 역전(IoC)시키는 것입니다.
  - **생성자 주입 (Constructor Injection)**: 객체를 생성할 때 생성자를 통해 의존성을 주입받는 방식. 불변성을 보장하고 순환 참조를 방지하는 등 가장 권장되는 방식.
  - **세터 주입 (Setter Injection)**: 세터(Setter) 메서드를 통해 의존성을 주입받는 방식. 선택적인 의존성을 주입할 때 유용.
  - **필드 주입 (Field Injection)**: 필드에 `@Autowired`와 같은 어노테이션을 사용하여 의존성을 주입받는 방식. 코드가 간결하지만 외부에서 객체를 수정하기 어렵고 테스트가 불편하다는 단점이 있어 권장되지 않음.

    ---

  ### **IoC를 사용하는 이유**
 - **낮은 결합도**: 객체들이 서로 직접적으로 의존하지 않으므로, 한 객체의 변경이 다른 객체에 미치는 영향을 최소화.
 - **재사용성 및 유연성**: 객체의 의존성이 외부에서 주입되므로, 동일한 객체를 다양한 환경에서 쉽게 재사용할 수 있음.
 - **테스트 용이성**: 외부 의존성을 쉽게 Mock 객체 등으로 교체할 수 있어 단위 테스트를 효과적으로 수행할 수 있음.

# **생성자 주입 vs 수정자, 필드 주입 차이**

  가장 큰 차이점 : **의존성을 주입하는 시점과 방식, 불변성**
    
  ---

  ### **생성자 주입 (Constructor Injection)**

  **객체가 생성되는 시점에** 생성자를 통해 필수 의존성을 주입.

    - **동작 방식**: 객체를 생성하는 시점에 생성자의 매개변수로 필요한 의존성 객체를 전달받.
    - **장점**:
        - **불변성**: `final` 키워드를 사용해 의존성이 주입된 후에는 변경되지 않도록 보장.
        - **필수 의존성**: 생성자에 인자가 없으면 객체 생성이 불가능하므로, 필수 의존성이 누락되는 문제를 원천적으로 막아줌.
        - **순환 참조 방지**: 순환 참조가 발생하면 애플리케이션 시작 단계에서 오류를 명확하게 알려줌.
    - **단점**:
        - 의존성이 많아질수록 생성자 코드가 길어짐.

    ---

  ### **수정자 주입 (Setter Injection)**

  **객체가 생성된 후에** Setter 메서드를 통해 의존성을 주입합니다.

    - **동작 방식**: 객체가 먼저 생성된 후, Setter 메서드를 호출하여 의존성을 주입.
    - **장점**:
        - **선택적 의존성**: 선택 사항인 의존성을 주입할 때 유용.
    - **단점**:
        - **불변성 없음**: 언제든 Setter를 호출해 의존성을 바꿀 수 있어 불변성을 보장하지 못함.
        - **객체 불완전성**: 주입이 완료되기 전에 객체가 사용될 위험이 있음.

    ---

  ### **필드 주입 (Field Injection)**

  **객체가 생성된 후에** 리플렉션을 이용해 필드에 직접 의존성을 주입.

    - **동작 방식**: 리플렉션(Reflection)을 통해 필드에 직접 의존성을 주입. 코드가 가장 간결함.
    - **장점**:
        - **코드 간결성**: 코드가 가장 간단함.
    - **단점**:
        - **불변성 없음**: `final` 키워드를 사용할 수 없어 불변성을 보장하지 못함.
        - **테스트 어려움**: 스프링 컨테이너 없이 단위 테스트를 하기가 매우 어려움.
        - **숨겨진 의존성**: 코드만 봐서는 어떤 의존성이 필요한지 명확하게 알기 어려움.


    **요약**: 생성자 주입은 **안정성과 불변성을 보장**하며, 수정자 주입은 **선택적 의존성에 유용**하고, 필드 주입은 **코드가 간결하지만 여러 단점**으로 인해 권장되지 않음.

# **AOP**

  관점 지향 프로그래밍(Aspect-Oriented Programming)**의 약자. 애플리케이션의 핵심 비즈니스 로직과 부가적인 기능(횡단 관심사)을 분리하여 모듈화하는 프로그래밍 패러다임.
    
  ---

  ### AOP의 개념

  AOP는 여러 곳에 흩어져 반복적으로 사용되는 기능들(예: 로깅, 보안, 트랜잭션 관리)을 하나의 **관점(Aspect)**으로 묶어 관리합니다. 이를 통해 **애플리케이션의 핵심 로직은 부가 기능에 대한 고민 없이 깔끔하게 유지될 수 있습니다.**  이처럼 AOP는 횡단 관심사를 분리하여 코드의 중복을 줄이고 유지보수를 용이하게 만듭니다.
    
  ---

  ### 주요 용어
  - **Aspect (관점):** 여러 클래스에 걸쳐 공통으로 사용되는 기능을 모듈화한 것. 예를 들어, 로깅 기능 자체가 하나의 관점이 될 수 있음.
  - **Join point (조인 포인트):** **Aspect가 적용될 수 있는 지점**을 의미. 메소드 호출, 필드 접근, 객체 생성 등 프로그램 실행 중 특정 지점을 말하며 스프링 AOP에서는 **메소드 실행 지점**만 조인 포인트로 사용.
  - **Advice (어드바이스):** **특정 조인 포인트에서 수행될 작업**. '언제(When)' '무엇(What)'을 할지를 정의.
  - **Before Advice:** 메소드 실행 전에 동작.
  - **After Returning Advice:** 메소드가 정상적으로 실행된 후 동작.
  - **After Throwing Advice:** 메소드 실행 중 예외가 발생했을 때 동작.
  - **After Advice:** 메소드 실행 결과에 상관없이 (정상 또는 예외 발생) 항상 동작.
  - **Around Advice:** 메소드 실행 전후에 모두 동작하며, 메소드 실행 자체를 제어할 수 있습니다.
  - **Pointcut (포인트컷):** **Advice를 적용할 조인 포인트를 선별하는 표현식**. 예를 들어, 특정 패키지의 모든 클래스 메소드를 지정하는 것과 같음.
  - **Weaving (위빙):** **Aspect를 대상 객체에 연결하는 과정**. 스프링 AOP는 런타임에 프록시 객체를 생성하여 위빙을 수행.

    ---

  ### AOP의 동작 방식

  AOP는 **프록시 기반**으로 동작.  스프링 컨테이너가 빈(Bean)을 생성할 때, AOP 설정에 따라 원래 객체(Target)를 감싸는 **프록시 객체**를 만듦. 이후 클라이언트가 원래 객체를 호출하면 프록시 객체가 대신 호출을 가로채고, 그 과정에서 Advice를 실행한 후 원래 객체의 메소드를 호출. 이 방식은 스프링 컨테이너가 관리하는 빈에만 AOP를 적용할 수 있다는 특징이 있.

# **서블릿**

  자바를 사용하여 웹 애플리케이션을 개발하기 위한 기술.

  ### 서블릿의 개념

  서블릿은 클라이언트의 요청에 대해 동적으로 작동하는 **서버 측 프로그램** 또는 그 프로그램을 작성하기 위한 기술. 웹 브라우저로부터 요청을 받으면, HTML을 생성하거나 데이터를 처리하여 다시 응답하는 역할.

  ### 서블릿의 동작 방식
  1. **클라이언트의 요청:** 사용자가 웹 브라우저에서 특정 URL을 요청.
  2. **웹 서버의 요청 처리:** 웹 서버(ex: Apache HTTP Server)가 요청을 받음.
  3. **컨테이너에 전달:** 웹 서버는 요청을 서블릿 컨테이너(ex: Tomcat, Jetty)에 전달.
  4. **서블릿 객체 생성:** 서블릿 컨테이너는 요청된 URL에 해당하는 서블릿이 메모리에 없는 경우, 해당 서블릿의 객체를 생성. 이 과정은 **최초의 요청 시 한 번만** 발생.
  5. **`init()` 메소드 호출:** 서블릿 컨테이너는 서블릿 객체 생성 후 `init()` 메소드를 호출하여 서블릿을 초기화함. 이 메소드 역시 한 번만 실행됨.
  6. **`service()` 메소드 호출:** 서블릿 컨테이너는 서블릿의 `service()` 메소드를 호출. 이 메소드는 HTTP 요청 메소드(GET, POST 등)에 따라 `doGet()`, `doPost()`와 같은 적절한 메소드를 호출.
  7. **`doGet()`/`doPost()` 메소드 실행:** 이 메소드 안에서 비즈니스 로직을 처리하고, 결과를 HTML 형태로 만들어 응답 객체에 담음.
  8. **컨테이너의 응답 처리:** 서블릿 컨테이너가 생성된 응답을 웹 서버에 전달하고, 웹 서버는 클라이언트에게 최종 응답을 보냄.
  9. **서블릿 소멸:** 서블릿 컨테이너가 종료되거나 서블릿이 더 이상 필요하지 않을 때, `destroy()` 메소드가 호출되어 서블릿 객체가 소멸됨.

  ### 서블릿의 특징
  - **자바 기반:** 자바의 강력한 기능(객체 지향, 멀티스레딩 등)을 활용할 수 있음.
  - **동적 페이지 생성:** HTML, CSS, JavaScript 등으로 구성된 정적 페이지와 달리, 클라이언트의 요청에 따라 동적으로 페이지를 생성할 수 있음.
  - **HTTP 프로토콜 지원:** HTTP의 GET, POST 등 다양한 요청 방식을 처리할 수 있음.
  - **상태 비저장(Stateless):** 기본적으로 서블릿은 클라이언트의 상태를 유지하지 않음.
  - **서블릿 컨테이너 의존:** 서블릿은 단독으로 실행될 수 없으며, 반드시 서블릿 컨테이너 내에서 동작해야함.