# WEEK 2 - 제이/한종서

## 핵심 키워드

### SOLID

#### 클린 코드로 유명한 로버트 C. 마틴이 정리한 좋은 객체지향 설계의 5가지 원칙이다.

1. SRP: 단일 책임 원칙(Single Responsibility Principle)

- 한 클래스는 하나의 책임만 가져야 한다.
- 책임은 매우 클 수도 있고, 작을 수도 있다. 따라서 상황에 따라 책임을 적절히 부여하는 것이 중요한데, 코드 변경이 불가피할 때 파급 효과가 적으면 SRP를 잘 따르도록 설계한 것이다.
- 한 클래스가 여러 역할을 하면 변경 요인이 늘어나면서 해당 클래스를 수정할 때 다른 기능이 의도치 않게 깨질 수 있다.
- 예시: 객체의 생성과 사용 분리, 객체의 기능 분리 등

2. OCP: 개방-폐쇄 원칙(Open/Closed Principle)

- 소프트웨어 구성 요소는 **확장**에는 열려 있고, **변경**에는 닫혀 있어야 한다.
- 새로운 요구 사항이 생겼을 때 기존 코드를 고치지 않고 확장만으로 대응할 수 있어야 비용을 줄일 수 있다.
- 다형성(Polymorphism)을 활용하여 역할(인터페이스)과 구현(클래스)을 분리한다.
- 예시: 전략(Strategy) 패턴 - 새로운 알고리즘을 추가할 때 기존 코드를 변경하지 않고 새 클래스를 등록하여 해결하는 디자인 패턴

3. LSP: 리스코프 치환 원칙(Liskov Substitution Principle)

- 자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다. 이는 프로그램의 어떤 객체를 하위 타입의 인스턴스로 교체할 수 있어야 한다는 뜻이다.
- 부모 타입을 사용하는 코드가 자식 타입 때문에 예외나 버그를 일으켜서는 안 된다. 이는 다형성을 지원하기 위한 원칙이다.
- 예시: 자동차 인터페이스의 엑셀은 앞으로 가는 기능이며, 뒤로 가게 구현하면 LSP 위반이다.

4. ISP: 인터페이스 분리 원칙(Interface Segregation Principle)

- 클라이언트는 사용하지 않는 메서드에 의존하지 않아야 한다. 범용 인터페이스 하나보다 특정 클라이언트를 위한 인터페이스 여러 개가 더 낫다.
- 불필요하게 큰 인터페이스를 구현하면, 구현 클래스가 쓸데없는 메서드를 억지로 오버라이딩하게 된다.
- 분리할수록 인터페이스가 명확해지고, 쉽게 대체할 수 있다.
- 예시: 어떤 기계가 프린트, 스캔, 팩스 기능을 모두 가지고 있을 때 이를 프린터, 스캐너, 팩스로 나눌 수 있다.

5. DIP: 의존관계 역전 원칙(Dependency Inversion Principle)

- 구현체에 의존하지 않고 인터페이스에 의존한다, 구체화가 아닌 추상화에 의존해야 한다는 원칙이다.
- 구현체가 바뀌더라도 상위 로직은 영향받지 않게 하여 변경이나 테스트를 쉽게 만들 수 있다.

#### 정리

SRP - 하나의 클래스는 하나의 책임을 가진다.

OCP - 확장에는 열려 있고, 수정(변경)에는 닫혀 있다.

LSP - 부모 타입 대신 자식 타입을 넣어도 문제 없어야 한다.(다형성 지원)

ISP - 인터페이스를 세분화한다.

DIP - 구현체가 아닌 인터페이스에 의존한다.

### DI

DI(Dependency Injection = 의존성 주입)는 객체를 직접 생성하지 않고, 외부에서 주입받아 사용하는 방식이다.

객체가 직접 의존성을 관리했는데, 이를 프레임워크나 외부 컨테이너가 대신 관리하게 한다.

개발자는 인터페이스를 설계하고, 구체적인 구현체는 스프링 컨테이너에게 알아서 연결해 달라는 표시만 남기면 된다.
스프링 컨테이너는 런타임에 적절한 구현체를 찾아서 주입해준다.

관련 어노테이션: @Component, @Autowired, @Configuration, @Bean...

### IoC

Inversion of Control의 약자로, 프로그램의 제어 흐름이 프레임워크에게 있음을 의미한다.

일반적으로 프로그램을 작성할 때는 객체의 생성, 설정, 초기화, 메서드 호출, 소멸까지 모든 과정을 개발자가 직접 제어해야 하지만, 프레임워크를 사용하면 객체의 생명 주기 관리를 프레임워크에게 전부 위임할 수 있다.

객체끼리의 의존성이 존재할 때, 의존성은 직접 관리하지 않고 외부에서 주입받는 방식을 채택하는 것이 좋다. 이를 통해 코드가 구체 구현체에 묶이는 것을 막고, 결합도를 낮출 수 있기 때문이다.

제어 흐름을 위임함으로써 개발자는 객체를 관리하지 않고 따로 해야 할 일에 집중할 수 있으며 테스트, 교체, 유지 보수 등의 비용을 줄여 **변화에 강한 설계**를 가능하게 한다.

### DI 방식(생성자, 수정자, 필드 주입 차이)

DI 방식은 3가지가 대표적이다.

1. 생성자 주입(권장)
2. Setter 주입
3. 필드 주입


1. 생성자 주입(권장)

- 의존 객체를 생성자 매개변수로 전달받는 방식이다.

```java
@Service
public class OrderService {
    private final Repository repository;
    
    @Autowired
    public OrderService(Repository repository) {
        this.repository = repository;
    }
}
```

- **객체가 생성될 때 의존성이 모두 주입되어 불변성이 유지된다.**
- Lombok 라이브러리의 `@RequiredArgsConstructor`로 생성자 코드를 대체할 수 있다.

2. Setter 주입

- 의존 객체를 Setter 메서드로 전달받는 방식이다.

```java
@Service
public class OrderService {
    private Repository repository;
    
    @Autowired
    public void setRepository(Repository repository) {
        this.repository = repository;
    }
}
```

- 객체 생성 이후에도 의존성을 변경할 수 있다.
- 필수가 아닌 선택적인 의존성을 다룰 때 유용하다.
- 하지만, 주입 시점이 늦어 불변성 보장이 어렵고 의존성이 필요한 프로그램에서 의존성 없이 프로그램이 시작되어 오류가 발생할 수 있다.

3. 필드 주입

- 의존 객체를 클래스의 필드에 바로 주입하는 방식이다.
- Setter 주입 방식과 마찬가지로, 런타임에 의존성을 주입하므로 의존성이 없을 때도 객체가 생성될 수 있다.
- 생성자나 Setter가 없기 때문에 의존 객체를 직접 주입하기가 까다로워 테스트하기 힘들고, 의존성을 주입해주는 프레임워크에 코드가 강하게 묶이게 된다.

스프링 프로젝트를 설계한다면 생성자 주입 방식을 기본으로 채택하고, 특수한 경우에만 Setter 주입 방식을 사용하는 것이 좋다.

이는 안정성과 테스트 용이성을 위함이다.

### AOP

- AOP(Aspect-Oriented Programming, 관점 지향 프로그래밍)는 **핵심 비즈니스 로직과 공통 관심사를 분리해 관리**하는 프로그래밍 방식이다.
- 예를 들어, 모든 메소드의 호출 시간을 측정하고 싶을 때 모든 메서드 코드에 시간을 측정하는 로직을 추가해야 한다.

AOP는 이런 공통 관심사를 한 군데에 모아 두고, 필요한 지점에 자동으로 삽입하도록 설계한다. 동작 흐름은 다음과 같다.

1. 개발자는 핵심 비즈니스 로직만 작성한다.
2. AOP 설정에서 **어떤 메서드가 실행될 때 어떤 Aspect를 어떻게 적용할지**를 정의한다.
3. 런타임 시 스프링이 프록시(proxy) 객체를 만들어 메서드의 실행 전후로 공통 기능을 삽입한다.

#### 핵심 용어

`Aspect`: 공통 기능을 담은 모듈

`Join Point`: Aspect가 적용될 수 있는 모든 지점

`Pointcut`: 실제로 Aspect를 적용할 지점(조건식)

`Advice`: 적용될 때 실행될 코드(Before, After, Around 등)

`Weaving`: Aspect를 실제 코드에 끼워 넣는 과정

클래스에 @Aspect를 붙여 AOP임을 알리면 되고, 어디에, 무엇을 끼워넣고 싶은지 코딩하면 된다.

#### 동작 방식

의존관계 사이사이에 프록시(쉽게 말하면 가짜) 객체를 두어 프록시 코드를 실행하게 한다. 위의 예에서, 프록시 코드에는 시간을 측정하는 로직이 들어 있다.

### 서블릿

- 서블릿은 HTTP 요청과 응답을 처리하기 위한 자바 표준 API 및 표준 규약이다.
- 서블릿이 등장하면서 HTTP 요청/응답 처리가 자동화되어 개발자는 핵심 비즈니스 로직에 집중할 수 있게 되었다. 서블릿 등장 이전, 개발자는 HTTP 요청 메시지를 파싱하고 응답 메시지를 만드는 등 반복적인 작업을 해야 했다.

#### 구체적인 역할

- 웹 브라우저(클라이언트)가 `/login`과 같은 요청을 보내면 서블릿 컨테이너(예시: Tomcat)가 이를 받아 지정된 서블릿 클래스에 전달한다. 즉, HTTP 요청을 수신한다.
- 개발자는 `HttpServletRequest`와 `HttpServletResponse` 객체를 통해 헤더, 쿼리 파라미터, 세션 등을 쉽게 읽고 HTML, JSON 같은 응답을 작성한다. 즉, 요청을 파싱하고 응답을 생성한다.

#### 자동화가 의미하는 부분

- 요청과 응답이 성립하기 위해서는 TCP 소켓을 열고 HTTP 프로토콜을 파싱하여 헤더와 바디를 분석한 후 응답하고자 하는 헤더와 바디를 채워넣고 응답한 후 TCP 소켓을 닫는 일련의 작업이 필요하다.
- 이러한 네트워크와 프로토콜의 세부 구현을 표준화하여 모델로 만들어 둠으로써 개발자는 이러한 부분은 서블릿에게 맡기고 핵심 비즈니스 로직 코드만 작성할 수 있게 된 것이다.

#### 확장

- JSP: 서블릿 위에서 동작하며, HTML 템플릿을 쉽게 작성하기 위한 기술이다.
- Spring MVC: 서블릿(특히 `DispatcherServlet`)을 기반으로 Controller와 View를 분리하고 DI와 같은 고수준의 기능을 제공한다.

#### 정리

서블릿은 HTTP 요청과 응답을 처리하기 위한 자바 표준 API 및 실행 모델로, 네트워크와 프로토콜의 세부 구현을 자동으로 처리해준다. 즉, 웹 애플리케이션의 핵심 기반을 제공하는 프레임워크적 표준이다.