# 외래키

## Foreigen Key(FK)

    - 다른 테이블의 기본 키를 참조하는 column(또는 column 집합)
    - 데이터 베이스에서 데이터 무결성(Integrity)를 유지하는 데 중요한 역할

## 특징

    1. 외래키를 사용하면 데이터 베이스에서 무결성을 유지할 수 있음 → 자식 테이블의 레코드를 삭제하거나 업데이트 할 때, 부모 테이블의 기본키를 참조하지 않으면 데이터 베이스에서 오류를 발생시킴 (데이터 무결성 유)
    2. 외래키를 가지고 있는 테이블 → 하위 테이블
       (기본키를 가지고 있는 테이블 → 참조 테이블 or 상위 테이블)
    3. 중복 O + NULL 값 O
    4. PK와 FK는 1:1 관계로 매칭. 기본 키에 존재하지 않는 값이 외부 키에 존재 X → FK 제한 표현으로 데이터 베이스에게 두 테이블 간의 관계를 알려 주어야 함

# 기본키

## Primary Key(PK)

    - 테이블 내의 각 행을 고유하게 식별하는 데에 사용되는 하나 또는 여러 개의 column의 집합
    - 테이블의 각 레코드에는 Primary Key 값이 반드시 있어야 함

## 특징

    1. 각 레코드에 대해 고유 → unique. 테이블 당 하나만 존재
    2. 중복 X + NULL 값 X
    3. 테이블에는 하나의 기본키만 가질 수 있지만 경우에 따라 1개 이상의 기본키를 정의할 수도 있다. (다수 열 기본 키, 복합 기본 키)

# ER 다이어그램

## ERD(Entity Relationship Diagram)

데이터 베이스 구조를 한눈에 알아보기 위해 그려 놓은 다이어그램
→ 개체와 관계를 중점적으로 표시

![image.png](attachment:057d575e-07ee-4c3a-a654-ccb0c775f333:image.png)

![image.png](attachment:24fb9043-d7b9-4539-b1d2-edf920109d37:image.png)

![image.png](attachment:a9709211-c085-44bc-a4dd-26613090a73e:image.png)

![image.png](attachment:93216248-e0a9-461e-aded-ca369c916bd5:image.png)

# 복합 키

## Composite Key

    - 두 개 이상의 column을 묶어서 하나의 기본키로 지정하는 것
    - 기본키는 하나의 테이블에 하나만 존재할 수 있음. 기본키는 하나 이상의 column으로 구성되어 있음
        - IF 기본키=복합키, 복합키 또한 유일성과 최소성을 만족시켜야 함

cf.

유일성: 하나의 키값으로 튜플을 유일하게 식별할 수 있는 성질을 의미함. (중복X)

최소성: 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성하는 성질.

# 연관관계

두 개 이상의 테이블 간의 존재하는 관계. 관계형 데이터 베이스(RDBMS)에서 많이 사용\

### 종류

    - 1:1 (1 to 1)
    - 1:N (1 to N)
    - N:1 (N to 1)
    - N:N (N to N)

# 정규화

## 정규화(Normalization)

하나의 테이블을 함수적 종속성의 특징을 토대로 분해해 가는 과정

## 정규화의 목적

→  보다 효율적인 스키마 구조를 만들기 위해

    - 데이터 구조의 안정성을 최대화 시킨다.
    - 중복을 배제하여 삽입, 삭제, 갱신 이상의 발생을 방지
    - 어떠한 릴레이션이라도 데이터 베이스 내에서 표현 가능하도록 한다.
    - 데이터 삽입 시, 릴레이션을 재구성할 필요성을 줄임
    - 효과적인 검색 알고리즘을 생성

## 제 1 정규화 (1NF)

→ 하나의 속성 안에는 하나의 값만 입력 되어야 함

릴레이션에 속한 모든 도메인이 원자값(Atomic Value)

    - 모든 열과 행의 중복 지점에는 (열과 행의) 해당되는 분야에서 한 개의 값을 가진다.
      (한 개의 값 ≠ 원자값 → 한 개의 값 = single value)

cf. 원자값 : 입력된 값을 쪼갤 수 있는가?

## 제 2 정규화 (2NF)

→ 1NF 중에서 복합 키가 기본 키로 구성되어 있는 경우에는 부분 함수적 종속이 있는지 확인 후, 있으면 부분 함수적 종속을 제거해서 완전 함수적 종속으로 만듦

키가 아닌 모든 속성들이 기본 키 완전 함수 종속 : 부분 함수 종속 X

## 제 3 정규화 (3NF)

→ 2NF를 만족하고 이행적 함수 종속을 테이블을 분해해서 없

키가 아닌 모든 속성들이 기본키에 이행적으로 함수 종속되지 않은 릴레이션

[정보처리 실기_데이터베이스06강_정규화](https://youtu.be/RXQ1kZ_JHqg?si=f0OPsoOWnJXSbqca)

# 반 정규화

## 반정규화(de-normalization)

정규화된 엔티티, 속성, 관계에 대해 시스템의 성능향상과 개발과 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링의 기법

즉, 성능 향상을 위해 정규화된 데이터 모델에서 중복, 통합, 분리 등을 수행하는 모든 과정을 의미한다. 반정규화를 적용하면 데이터 무결성이 깨질 수 있는 위험이 있다.

![image.png](attachment:aaa9bc15-4230-4a34-ac40-cfd64267f116:image.png)

![image.png](attachment:ff26ba25-15c4-4014-8d22-03155cd6abe9:image.png)

# DB에서의 상속 관계 표현
## 단일 테이블 상속 (Single Table Inheritance)

**단일 테이블 상속**은 모든 부모-자식 클래스를 하나의 테이블에 저장하는 방식입니다. 모든 자식 클래스의 모든 속성을 포함하는 **단일 테이블**을 만들고, **유형 식별자(discriminator)** 열을 추가하여 각 행이 어떤 자식 클래스에 속하는지 구분합니다.

- **장점:**
    - 간단한 구조로, 조회 시 조인(JOIN)이 필요 없어 **성능이 빠릅니다**.
    - 부모 클래스나 모든 자식 클래스를 한 번에 조회하기 쉽습니다.
- **단점:**
    - 모든 자식 클래스의 속성이 한 테이블에 있어 **불필요한 NULL 값**이 많아집니다.
    - 테이블의 열(column)이 매우 많아질 수 있고, 데이터베이스의 **정규화 원칙에 위배**될 수 있습니다.

---

## 클래스당 테이블 (Table Per Class)

**클래스당 테이블**은 부모 클래스와 각 자식 클래스를 각각 **별도의 테이블**로 나누어 저장하는 방식입니다. 부모 테이블과 자식 테이블은 **동일한 기본 키(primary key)**를 공유하며 연결됩니다.

- **장점:**
    - 테이블 구조가 직관적이고, **정규화 원칙**을 잘 지킵니다.
    - NULL 값이 없어 데이터 낭비가 적습니다.
- **단점:**
    - 전체 클래스 계층을 조회할 때 **여러 테이블을 UNION**해야 하므로 쿼리가 복잡해지고 성능이 저하될 수 있습니다.
    - 부모 테이블의 데이터와 함께 자식 테이블의 데이터를 조회하려면 조인이 필요합니다.

---

## 조인 전략 (Joined Table Inheritance)

**조인 전략**은 부모 클래스를 위한 테이블과 각 자식 클래스를 위한 테이블을 **별도로 생성**하고, 부모 테이블의 기본 키를 자식 테이블의 **외래 키(foreign key)**로 참조하여 연결하는 방식입니다. 부모-자식 관계는 1:1로 설정됩니다.

- **장점:**
    - **정규화가 잘 되어** 데이터 중복이 없고, NULL 값도 발생하지 않습니다.
    - 각 테이블이 특정 클래스의 속성만 포함하므로 테이블 구조가 깔끔합니다.
- **단점:**
    - 자식 클래스 객체를 조회할 때 항상 **조인(JOIN) 연산**이 필요하므로 성능에 영향을 줄 수 있습니다.
    - 쿼리 로직이 다른 두 방법에 비해 상대적으로 복잡해질 수 있습니다.

# 인덱스
- 데이터베이스 테이블의 **검색 속도를 높이는** 자료구조. 특정 키에 대한 데이터의 물리적 위치를 빠르게 찾아내어 전체 데이터를 스캔할 필요 없이 원하는 정보를 신속하게 검색할 수 있음.

  ### 인덱스 사용의 장점과 단점

  **장점:**

    - **빠른 검색 속도**: `SELECT`, `UPDATE`, `DELETE`와 같은 쿼리의 성능을 향상시킵니다.
    - **정렬 및 그룹화 용이**: 인덱스가 정렬된 상태이므로 `ORDER BY`나 `GROUP BY` 절을 사용할 때 효율적입니다.

  **단점:**

    - **추가 저장 공간**: 인덱스는 별도의 저장 공간을 필요로 합니다.
    - **성능 저하**: `INSERT`, `UPDATE`, `DELETE` 작업 시, 데이터와 함께 인덱스도 갱신해야 하므로 **쓰기 작업의 성능이 저하**될 수 있습니다.

  따라서 인덱스는 **읽기(Read)** 작업이 빈번하고 **쓰기(Write)** 작업이 적은 테이블에 주로 사용하며, 모든 컬럼에 무분별하게 인덱스를 생성하는 것은 오히려 시스템의 성능을 저하시킬 수 있으므로 신중하게 설계해야 함.